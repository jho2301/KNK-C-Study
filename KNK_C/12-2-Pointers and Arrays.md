#### 12.4 다차원 배열과 포인터

일차원 배열과 마찬가지로 다차원 배열의 원소도 포인팅 할 수 있음.

- **다차원 배열에서 원소를 처리하는 법**

  다차원 배열도 행단위의 배열이 메모리 상에 일렬로 나열되어 있는 형태이기 때문에 포인터를 이용하여 순차적으로 접근이 가능하다. (267페이지)

  ```c
  /*모든 원소 0으로 초기화*/
  
  /*이중포문*/
  int row, col;
  for( row = 0; row < NUM_ROWS; row++)
  	for( col = 0; col <NUM_COLS; col++)
          a[row][col] = 0;
  /*---------------------------------------*/
  
  /*포인터를 이용(하나의 포문)*/
  int *p;
  
  for(p = &a[0][0]; p <= &a[NUM_ROWS-1][NUM_COLS-1]; p++)
      *p = 0;
  ```

  다차원 배열을 마치 일차원 배열 처럼 다룰 수 있다. 

  &a\[0][0]은 배열의 가장 첫 주소를 나타낸다.

  오래된 컴파일러에서는 일차원 배열처럼 다루는 것이 효율적인 측면에서 이점이 있지만, 최신 컴파일러에서는 거의 차이가 없다.

  

- **다차원 배열에서 행을 처리하는 법**

  `p = &a[i][0]` 은 i행의 첫 번째 원소의 주소를 포인터에 담는 것

  `p = &a[i][0]` 은 `p=&a[i]` 로 표현 가능하다. ( 1차원 배열에서 `a[i]` 는 `*(a+i)`와 동일하다. 그러므로, 2차원 배열에서는 `&a[i][0]`은 `&( *( a[i] + 0 ) )`와 동일하고  `&*a[i]` 이렇게 변형이 가능하다. *와 &는 상쇄가 되어 `a[i]`로 표현이 가능하다)

  ```c
  /*i번째 행을 0으로 초기화 하는 법*/
  
  int *p, i, a[NUM_ROWS][NUM_COLS];
  ...
  for(p = &a[i]; p < a[i] + NUM_COLS; p++)
      *p = 0;
  ```

   한 행을 1차원 배열 처럼 함수의 아규먼트로 활용 할 수 있다.

  ```CQL
  largest = find_largest(a[i], NUM_COLS);
  ```

  

- **배열에서 열을 처리하는 법**

  ```c
  /*i번째 열을 0으로 초기화 하는 법*/
  
  int i, a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS];
  ...
  for(p = &a[0]; p < &a[NUM_ROWS]; p++)
      (*p)[i] = 0;
  ```

  변수 선언에서 `int (*p)[NUM_COLS]`는 길이가 int형 배열의 길이가 NUM_COLS 인 배열을 가리키는 포인터를 의미한다. 이때 ()를 생략하면 안된다.(괄호를 생략하게 되면 배열의 포인터가 아닌, 포인터의 배열로 인식함) 

  `p++`은 p를 다음 행의 첫 번째 원소의 주소로 증가시켜준다.

  `(*p)[i]` 은 각 행의 i번째 원소에 접근한는 방법이다. (이때 `*p`자체는 하나의 배열을 의미 한다. 즉 *p는 길이가 NUM_COLS인 1차원 배열의 이름과 같다고 볼 수 있다.) 이때 괄호를 생략하면 안된다.( *p[i]를 *( p[i] )로 해석하기 때문에 )

  

- **다중 배열의 이름을 포인터로 활용는 법**

  `int a[NUM_ROWS][NUM_COLS];` 의 배열의 `a`는 `a[0][0]`의 포인터가 아니라 `a[0]`의 포인터라고 생각하는 게 좋다. `a`의 타입은 `int (*) [NUM_COLS]` (길이가 NUM_COLS인 int형 배열을 가리키는 포인터)

  a[0] 는 2차원 배열의 처리를 하는 간단한 방법이다.

  ```c
  /*i번 째 열을 초기화 하는 방법*/
  for(p= &a[0]; p<&a[NUM_ROWS]; p++){
      (*p)[i] = 0;
  }
  //아래 방법도 사용가능하다.
  for(p= &a[0]; p< a + NUM_ROWS; p++){
      (*p)[i] = 0;
  }
  ```

  다차원 배열을 1차원 배열처럼 사용할 때 주의 해야할 점이 있다.

  a와 a[0]의 차이를 먼저 이해해야 한다.

  a의 자료형은 `int (*) [NUM_COLS]`으로 a+1을 하면 배열의 길이만큼 메모리를 점프한다.

  a[0]의 자료형은 `int(*)`으로 a[0]+1을 하면 int 하나만큼의 길이를 점프한다.

  따라서 `largest = find_largest(a, NUM_ROWS * NUM_ COLS)`는 잘못되었다.

   `largest = find_largest(a[0], NUM_ROWS * NUM_ COLS)`이 맞는 표현이다.



포인터.. #include <typeinfo>

#### 12.5 포인터와 VLA

- C99에서 가변 길이 배열 

  ```c
  void f(int n)
  {
  	int a[n], *p;
  	p=a;
      ....
  }
  ```

- 다중배열 VLA

  ```c
  void f(int m, int n)
  {
  	int a[m][n], (*p)[n];
  	p=a;
      ....
  }
  ```

  p는 n의 크기에 따라 결정되고  n은 상수가 아니기 때문에, p는 v**ariably modified type** 이라고 불린다. p=a;의 가능여부는 컴파일러에 의해 결정되지 않는다. 예를 들어

  ```c
  int a[m][n], (*p)[m];   // (*p)[n]이 아님..
  p=a;
  ```

  위의 경우 m과 n이 같은 값이 아니라면 비정의 행동을 할 것이다. 따라서 m과 n이 같을 때에만 정상 동작하게 된다.

  VLA처럼 **variably modified type**은 특정한 제약에 지배를 당한다. 가장 중요한 제약은 variably modified type은 함수의 body나 prototype에 선언이 되어야 한다는 것이다.  

  VLA의 Pointer arithmetic은 일반적인 배열의 방식과 동일하게 동작한다.

  ```c
  int a[m][n];
  int (p*)[n];
  
  for (p=a; p<a+m; p++)
      (*p)[i] = 0;
  ```

  